class Sort{
	/**	
	 * 1、直接插入排序
	 * 将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。
	 * 即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行
	 * 插入，直至整个序列有序为止。
	 * 特点：稳定。
	 * 时间复杂度：O（n^2）.
	*/
	public static void insertSort(int[] num){   
		for(int i=1; i<num.length; i++){
//			int j = 0;                  //从头向后比
//			int x = num[i];
//			while(num[i]>num[j]&&j<i){
//				j++;
//			}
//			for(int k=j;k<=i;k++){
//				int y = num[k];
//				num[k]=x;
//				x=y;
//			}
			if(num[i]<num[i-1]){        //从后向前比，如果第i个大于第i-1个不用调整
				int j=i-1;
				int x = num[i];
				while(j>=0&&x<num[j]){
					num[j+1]=num[j];
					j--;
				}
				num[j+1] = x;
			}
		}
	}
	/**
	 *	2、希尔 排序(缩小增量排序，插入排序的改进)
	 * 		基本思想：
	 * 			先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。
	 * 		操作方法：
	 * 			选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
	 * 			按增量序列个数k，对序列进行k 趟排序；
	 * 			每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
	 * 
	 **/
	public static void shellSort(int[] num){
		int n = num.length;
		int dk = n/2;
		while(dk>=1){
			for(int i=dk; i<n; i++){
				if(num[i]<num[i-dk]){        //从后向前比，如果第i个大于第i-1个不用调整
					int j=i-dk;
					int x = num[i];  //x=55
//					num[i]=num[i-dk];
					while(j>=0&&x<num[j]){
						num[j+dk]=num[j];   
						j-=dk;
					}
					num[j+dk] = x;
				}
			}
			dk=dk/2;
		}
	}
	/**
	 * 	3. 选择排序—简单选择排序（Simple Selection Sort）
	 * 		基本思想：
	 * 			在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。
	 * 		操作方法：
	 * 			第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；
	 * 			第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；
	 * 			以此类推.....
	 * 			第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，
	 * 			直到整个序列按关键码有序。
	 **/
	public static void selectMinKey(int[] num){
//		int x;
//		int n=num.length;
//		for(int i=0; i<n; i++){
//			x=num[i];
//			for(int j=i+1; j<n; j++){
//				if(num[j]<x){
//					int temp=x;
//					x=num[j];
//					num[j]=temp;
//				}
//			}
//			num[i] = x;
//		}
		int n=num.length;
		for(int i=0; i<=n/2; i++){
			int min=i,max=i;           //一次循环同时找出一个最大、最小值
			for(int j=i+1; j<n-i; j++){
				if(num[min]>num[j]) min=j;
				if(num[max]<num[j]) max=j;
			}
			if(min!=i){
				int temp = num[i];
				num[i]=num[min];
				num[min]=temp;
				temp=num[n-i-1];
				num[n-i-1]=num[max];
				num[max]=temp;
			}
		}
	}
	/**
	 	4、冒泡排序 
	 
	 */
	public static void bubbleSort(int[] num){
		int n=num.length;
//		for(int i=0; i<n-1; i++){
//			for(int j=0; j<n-i-1;j++){
//				if(num[i]>num[i+1]){
//					int temp = num[i];
//					num[i]=num[i+1];
//					num[i+1]=temp;
//				}
//			}
//		}
		/**双向冒泡**/
		 int low = 0;     
		 int high= n -1; //设置变量的初始值
		 int tmp,j;  
		 while (low < high) {  
			 for (j= low; j< high; ++j){ //正向冒泡,找到最大者  
				 if (num[j]> num[j+1]) {  
					 tmp = num[j]; num[j]=num[j+1];num[j+1]=tmp;  
				 }   
			 	--high;                 //修改high值, 前移一位  
			 }
			 for ( j=high; j>low; --j) {//反向冒泡,找到最小者  
				 if (num[j]<num[j-1]) {  
					 tmp = num[j]; num[j]=num[j-1];num[j-1]=tmp;  
				 }  
				 ++low;                  //修改low值,后移一位 
			 }
		 }
	}
	/**
	 	快速排序
	 */
	public static void quickSort(int[] num,int low,int high){
		if(low<high){
			int mid = partition(num, low, high);
			quickSort(num,low,mid-1);
			quickSort(num,mid+1,high);
		}
	}
	private static int partition(int[] num,int low,int high){
		int privotkey = num[low];
		while(low<high){
			while(low<high&&num[high]>=privotkey) high--;
			int temp = num[high];
			num[high]=num[low];
			num[low]=temp;
			while(low<high&&num[low]<=privotkey) low++;
			temp = num[high];
			num[high]=num[low];
			num[low]=temp;
		}
		return low;
	}
}
class Test{
	public static void main(String[] args) {
		int[] n ={63,40,444,23,5,34,55,954,7,34};
		Sort.quickSort(n, 0, 9);;
		for(int i=0; i<n.length; i++) System.out.println(n[i]);
	}
}
